<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Sistema de Diagnóstico - Impresora HP DeskJet 2723</title>
  <style>
    /* Layout de dos columnas */
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
    }
    .main-container {
      display: flex;
      min-height: 100vh;
    }
    /* Panel izquierdo: “chat” de preguntas y respuestas */
    .left-panel {
      flex: 2;
      background: #fff;
      padding: 20px;
      overflow-y: auto;
    }
    /* Panel derecho: diagrama / línea de razonamiento */
    .right-panel {
      flex: 1;
      background: #fafafa;
      border-left: 1px solid #ccc;
      padding: 20px;
      overflow-y: auto;
    }
    h1, h2 {
      text-align: center;
      margin-top: 0;
    }
    /* Contenedor para cada “mensaje” en el chat */
    .message {
      margin-bottom: 20px;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #ddd;
    }
    .question-header {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .question-text {
      margin-bottom: 10px;
    }
    .answers {
      margin-bottom: 10px;
    }
    label {
      margin-right: 20px;
    }
    .conclusion {
      background: #e0ffe0;
      border: 1px solid #00cc00;
    }
    button {
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
    }
    button:hover {
      background: #0056b3;
    }
    /* Estilos para el diagrama de inferencia (panel derecho) */
    .flow-node {
      padding: 10px;
      margin: 10px 0;
      border: 2px solid #ccc;
      border-radius: 4px;
      background: #fff;
    }
    .flow-node h3 {
      margin: 0 0 5px 0;
      font-size: 16px;
      font-weight: bold;
    }
    .flow-node p {
      margin: 0;
      font-size: 14px;
    }
    .flow-arrow {
      width: 2px;
      height: 20px;
      background: #999;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div class="main-container">
    <!-- Panel Izquierdo: Chat acumulativo -->
    <div class="left-panel">
      <h1>Diagnóstico de la Impresora</h1>
      <div id="chatContainer">
        <!-- Se irán agregando las preguntas y conclusiones sin borrar las anteriores -->
      </div>
    </div>

    <!-- Panel Derecho: Diagrama de inferencia en tiempo real -->
    <div class="right-panel">
      <h2>Línea de Razonamiento</h2>
      <div id="diagramContainer">
        <!-- Se muestra el camino recorrido con indentación -->
      </div>
    </div>
  </div>

  <script>
    /***********************************************************************
     * 1. DEFINICIÓN DE NODOS (REGLAS Y CONCLUSIONES)
     ***********************************************************************/
    /*
      Cada nodo es un objeto con:
      - id: identificador único.
      - type: "question" o "conclusion".
      - text: texto a mostrar.
      - yes: id del siguiente nodo si la respuesta es "Sí".
      - no:  id del siguiente nodo si la respuesta es "No".
      
      En este ejemplo se crean ramas para ambas situaciones:
      • Si la impresora enciende correctamente se sigue la rama "lineal".
      • Si no enciende se inicia una serie de preguntas anidadas.
      
      Cada nodo que se agrega se mostrará con un nivel (depth) incrementado para reflejar la jerarquía.
    */
    const nodes = {
      // Nodo inicial
      start: {
        id: "start",
        type: "question",
        text: "¿La impresora enciende correctamente?",
        yes: "q1",    // Rama lineal si enciende
        no: "p0"      // Rama anidada si no enciende
      },

      /* Rama anidada para cuando NO enciende */
      p0: {
        id: "p0",
        type: "question",
        text: "La impresora no enciende. ¿Está enchufada al tomacorriente?",
        yes: "p1",
        no: "c0"
      },
      p1: {
        id: "p1",
        type: "question",
        text: "¿Está enchufada a la parte posterior de la impresora?",
        yes: "p2",
        no: "c1"
      },
      p2: {
        id: "p2",
        type: "question",
        text: "Al conectar todo, ¿la luz se enciende en amarillo?",
        yes: "c2",
        no: "c3"
      },
      c0: {
        id: "c0",
        type: "conclusion",
        text: "La impresora no está enchufada. Conéctela al tomacorriente y vuelva a intentarlo."
      },
      c1: {
        id: "c1",
        type: "conclusion",
        text: "La impresora podría no estar correctamente conectada en la parte posterior. Verifique la conexión."
      },
      c2: {
        id: "c2",
        type: "conclusion",
        text: "La luz amarilla indica un fallo interno. Consulte el servicio técnico."
      },
      c3: {
        id: "c3",
        type: "conclusion",
        text: "Si la luz no se enciende, revise la fuente de poder o contacte soporte."
      },

      /* Rama lineal para cuando SI enciende */
      q1: {
        id: "q1",
        type: "question",
        text: "¿La luz Wi-Fi está encendida (fija o parpadeando)?",
        yes: "q2",
        no: "c4"
      },
      q2: {
        id: "q2",
        type: "question",
        text: "¿La luz Wi-Fi parpadea en azul?",
        yes: "c5",
        no: "q3"
      },
      c4: {
        id: "c4",
        type: "conclusion",
        text: "La impresora no está conectada a Wi-Fi. Reinicie el modo de configuración inalámbrica."
      },
      c5: {
        id: "c5",
        type: "conclusion",
        text: "La impresora está en modo configuración Wi-Fi. Use la app HP Smart para finalizar la conexión."
      },
      q3: {
        id: "q3",
        type: "question",
        text: "¿El indicador luminoso de tinta está encendido?",
        yes: "c6",
        no: "q4"
      },
      c6: {
        id: "c6",
        type: "conclusion",
        text: "El nivel de tinta es bajo o hay un problema con el cartucho. Revise o reemplace el cartucho."
      },
      q4: {
        id: "q4",
        type: "question",
        text: "¿La impresión sale borrosa o con rayas?",
        yes: "c7",
        no: "c8"
      },
      c7: {
        id: "c7",
        type: "conclusion",
        text: "Los inyectores pueden estar obstruidos. Realice una limpieza del cabezal de impresión."
      },
      c8: {
        id: "c8",
        type: "conclusion",
        text: "Verifique que los cartuchos estén bien instalados y que el papel sea de buena calidad."
      }
    };

    /***********************************************************************
     * 2. GESTIÓN DE ESTADO
     ***********************************************************************/
    let currentNodeId = "start";
    // Array que almacena el camino recorrido: cada entrada incluye { nodeId, type, text, answer, depth }
    const inferencePath = [];

    /***********************************************************************
     * 3. FUNCIONES PARA RENDERIZAR EL CHAT Y DIAGRAMA
     ***********************************************************************/
    // La función showNode muestra el nodo actual en el chat y actualiza el diagrama.
    // Se recibe además el parámetro 'depth' para reflejar el nivel de anidamiento.
    function showNode(nodeId, answer = "start", depth = 0) {
      const node = nodes[nodeId];

      // Agregamos el nodo al camino de inferencia, incluyendo el nivel (depth)
      inferencePath.push({
        nodeId: node.id,
        type: node.type,
        text: node.text,
        answer: answer,
        depth: depth
      });

      // Actualizamos el diagrama en el panel derecho
      updateDiagram();

      // Creamos un contenedor para este mensaje en el chat
      const messageEl = document.createElement("div");
      messageEl.classList.add("message");
      // Aplicamos indentación según el nivel (depth)
      messageEl.style.marginLeft = (depth * 20) + "px";

      if (node.type === "question") {
        messageEl.innerHTML = `
          <div class="question-header">Pregunta [${node.id}]</div>
          <div class="question-text">${node.text}</div>
          <div class="answers">
            <label>
              <input type="radio" name="answer-${node.id}" value="yes" /> Sí
            </label>
            <label>
              <input type="radio" name="answer-${node.id}" value="no" /> No
            </label>
          </div>
          <button id="btn-${node.id}">Siguiente</button>
        `;
        chatContainer.appendChild(messageEl);

        // Asignamos el listener para el botón de respuesta
        const btnNext = document.getElementById(`btn-${node.id}`);
        btnNext.addEventListener("click", () => {
          const selected = document.querySelector(`input[name="answer-${node.id}"]:checked`);
          if (!selected) {
            alert("Por favor, selecciona Sí o No.");
            return;
          }
          const userAnswer = selected.value;
          // Deshabilitar opciones para que no se modifiquen
          btnNext.disabled = true;
          const radios = messageEl.querySelectorAll(`input[name="answer-${node.id}"]`);
          radios.forEach(r => r.disabled = true);

          // En este ejemplo, para cualquier respuesta se incrementa el nivel de anidamiento.
          const nextDepth = depth + 1;
          goToNextNode(node, userAnswer, nextDepth);
        });

      } else { // Caso de conclusión
        messageEl.classList.add("conclusion");
        messageEl.innerHTML = `
          <div class="question-header">Conclusión [${node.id}]</div>
          <div class="question-text">${node.text}</div>
        `;
        chatContainer.appendChild(messageEl);
      }

      // Scroll automático para que siempre se vea la última entrada
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // Función que decide y muestra el siguiente nodo, pasando el 'depth' calculado
    function goToNextNode(node, answer, nextDepth) {
      const nextId = (answer === "yes") ? node.yes : node.no;
      if (nextId) {
        showNode(nextId, answer, nextDepth);
      } else {
        const msg = document.createElement("div");
        msg.innerHTML = "<p>No se encontró el siguiente paso en la red de inferencia.</p>";
        chatContainer.appendChild(msg);
      }
    }

    // Función para actualizar el diagrama en el panel derecho según el camino recorrido
    function updateDiagram() {
      diagramContainer.innerHTML = "";
      inferencePath.forEach((step, index) => {
        const stepEl = document.createElement("div");
        stepEl.classList.add("flow-node");
        // Indentación según el nivel (depth)
        stepEl.style.marginLeft = (step.depth * 20) + "px";

        // Colorear el borde según la respuesta
        if (step.answer === "yes") {
          stepEl.style.borderColor = "green";
        } else if (step.answer === "no") {
          stepEl.style.borderColor = "red";
        }
        if (step.type === "question") {
          stepEl.innerHTML = `
            <h3>Pregunta [${step.nodeId}]</h3>
            <p>${step.text}</p>
          `;
        } else {
          stepEl.innerHTML = `
            <h3>Conclusión [${step.nodeId}]</h3>
            <p>${step.text}</p>
          `;
        }
        diagramContainer.appendChild(stepEl);
        // Dibujar una flecha simple entre cada nodo (excepto el último)
        if (index < inferencePath.length - 1) {
          const arrowEl = document.createElement("div");
          arrowEl.classList.add("flow-arrow");
          diagramContainer.appendChild(arrowEl);
        }
      });
    }

    /***********************************************************************
     * 4. INICIALIZACIÓN
     ***********************************************************************/
    // Referencias a los contenedores
    const chatContainer = document.getElementById("chatContainer");
    const diagramContainer = document.getElementById("diagramContainer");

    // Iniciar el proceso mostrando el nodo inicial (depth = 0)
    showNode(currentNodeId, "start", 0);
  </script>
</body>
</html>
